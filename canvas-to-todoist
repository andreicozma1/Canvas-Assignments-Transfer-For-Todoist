#!/usr/bin/python3
"""
Modifications by Andrei Cozma which are based on the original code from the following repository:
https://github.com/scottquach/Canvas-Assignments-Transfer-For-Todoist

What's new:
- Use the 'canvasapi' library instead of requests for shorter/cleaner code
- Use the 'pick' library for better multiple-item selection
- Added ability to rename a course as it appears as a Todoist project (can optionally use the default name from Canvas)
- Automatically set task priority based on keywords (configurable)
- Print short and detailed summaries after assignment transfer.
  - Shows counts of new assignments, updated assignments, and skipped assignments (already submitted or already up to date)
- Optional file downloading capability
- Reformatted print statements for better verbosity and readability.


Huge thanks to scottquach and stacksjb for their awesome work on this project.
"""

import argparse
import logging
import os
import sys
from datetime import datetime

import appdirs

from helpers.CanvasHelper import CanvasHelper
from helpers.ConfigHelper import ConfigHelper
from helpers.NotificationHelper import NotificationHelper
from helpers.TodoistHelper import TodoistHelper

appname = "CanvasToTodoist"
appauthor = "GitHub Community"
os_save_path = appdirs.user_data_dir(appname, appauthor)
os.makedirs(os_save_path, exist_ok=True)
os_config_path = appdirs.user_config_dir(appname, appauthor)
os.makedirs(os_config_path, exist_ok=True)
os_log_path = appdirs.user_log_dir(appname, appauthor)
os.makedirs(os_log_path, exist_ok=True)

# Set up logging
log_fn = "canvas-to-todoist.log"
log_path = os.path.join(os_log_path, log_fn)
log_handlers = [logging.FileHandler(log_path, mode='w'),
                logging.StreamHandler()]
# handlers = [logging.FileHandler(f"{logfilename}.log", mode='w')]
logging.basicConfig(
    level=logging.INFO,
    format="%(message)s",
    # format="%(asctime)s %(levelname)6s : %(message)s [%(funcName)s():%(lineno)s]",
    handlers=log_handlers
)


class CanvasFileDownloader:
    def __init__(self, skip_confirmation_prompts=False):
        self.input_prompt = "> "
        self.skip_confirmation_prompts = skip_confirmation_prompts
        self.param = {'per_page': '100', 'include': 'submission'}

        self.config_path = os.path.join(os_config_path, "config.json")
        self.config_helper = ConfigHelper(self.config_path, self.input_prompt, self.skip_confirmation_prompts)

        self.canvas_helper = CanvasHelper(self.config_helper.get('canvas_api_key'))
        self.selected_course_ids = self.canvas_helper.select_courses(self.config_helper,
                                                                     skip_confirmation_prompts=self.skip_confirmation_prompts)

    def run(self):
        if not self.skip_confirmation_prompts:
            use_previous_input = input(
                "Q: Would you like to download all files for these courses? (Y/n) ")
        else:
            use_previous_input = "y"

        if use_previous_input.lower() == "y":
            self.load_save_paths()
            self.canvas_helper.download_course_files_all(self.selected_course_ids, self.param)
            self.canvas_helper.download_module_files_all(self.selected_course_ids, self.param)

    def load_save_paths(self):
        has_missing = False

        for i, (c_id, c_obj) in enumerate(self.selected_course_ids.items()):
            if 'save_path' not in c_obj or c_obj['save_path'] == "" or c_obj['save_path'] is None:
                has_missing = True
                break

        if not has_missing:
            logging.info("# You have previously selected download paths:")
            for i, (c_id, c_obj) in enumerate(self.selected_course_ids.items()):
                logging.info(f"  {i + 1}. {c_obj['name']}: `{c_obj['save_path']}`")
            if not self.skip_confirmation_prompts:
                use_previous_input = input(
                    "Q: Would you like to use the download paths selected last time? (Y/n) ")
            else:
                use_previous_input = "y"
            logging.info("")
            if use_previous_input.lower() == "y":
                return

        for course_id, c_obj in self.selected_course_ids.items():
            c_name = c_obj['name']
            logging.info(f"# Course: {c_name}")

            def_save_path = os.path.join(os_save_path, c_name)
            logging.info(f"  - Default: {def_save_path}")
            if self.skip_confirmation_prompts:
                logging.error("You must configure save paths."
                              "Please run without -y argument to configure.")
                sys.exit(1)
            save_path = input(f"  - Enter new path, or press return to use default: ")
            if save_path.strip() == "":
                save_path = def_save_path
            self.selected_course_ids[course_id]['save_path'] = save_path

        logging.info("")

        self.config_helper.set('courses', self.selected_course_ids)


class CanvasToTodoist:

    def __init__(self, skip_confirmation_prompts=False):
        self.skip_confirmation_prompts = skip_confirmation_prompts
        self.param = {'per_page': '100', 'include': 'submission'}
        self.input_prompt = "> "
        self.selected_course_ids = None

        # Loaded configuration files
        self.config_path = os.path.join(os_config_path, "config.json")
        self.config_helper = ConfigHelper(self.config_path, self.input_prompt, self.skip_confirmation_prompts)

        self.canvas_helper = CanvasHelper(self.config_helper.get('canvas_api_key'))
        self.todoist_helper = TodoistHelper(self.config_helper.get('todoist_api_key'))

    def run(self):
        todoist_project_names = self.todoist_helper.get_project_names()
        self.selected_course_ids = self.canvas_helper.select_courses(self.config_helper,
                                                                     todoist_project_names,
                                                                     self.skip_confirmation_prompts)

        course_names = self.canvas_helper.get_course_names(self.selected_course_ids)

        self.todoist_helper.create_projects(course_names)

        assignments = self.canvas_helper.get_assignments(self.selected_course_ids, self.param)
        self.transfer_assignments_to_todoist(assignments)
        logging.info("# Finished!")

    def check_existing_task(self, assignment, project_id):
        """
        Checks to see if a task already exists for the assignment.
        Return flags for whether the task exists and if it needs to be updated,
        as well as the corresponding task object.
        """
        is_added = False
        is_synced = True
        item = None
        for task in self.todoist_helper.get_tasks():
            task_title = TodoistHelper.make_link_title(assignment["name"], assignment["html_url"])
            # If title and project match, then the task already exists
            if task['content'] == task_title and task['project_id'] == project_id:
                is_added = True
                # Check if the task is synced by comparing due dates and priority
                if (task['due'] and task['due']['date'] != assignment['due_at']) or \
                        task['priority'] != assignment['priority']:
                    is_synced = False
                    item = task
                    break
        return is_added, is_synced, item

    def transfer_assignments_to_todoist(self, assignments):
        """
        Transfers over assignments from Canvas over to Todoist.
        The method Checks to make sure the assignment has not already been transferred to prevent overlap.
        """
        logging.info("# Transferring assignments to Todoist...")

        summary = {'added': [], 'updated': [],
                   'is-submitted': [], 'up-to-date': []}

        for i, c_a in enumerate(assignments):
            # Get the canvas assignment name, due date, course name, todoist project id
            c_n = c_a['name']
            c_d = c_a['due_at']
            c_cn = self.selected_course_ids[str(c_a['course_id'])]['name']
            t_proj_id = self.todoist_helper.get_project_id(c_cn)

            # Find the corresponding priority based on the assignment properties
            priority = TodoistHelper.find_priority(c_a)
            c_a['priority'] = priority

            # Check if the assignment already exists in Todoist and if it needs updating
            is_added, is_synced, item = self.check_existing_task(c_a, t_proj_id)
            logging.info(f"  {i + 1}. Assignment: \"{c_n}\"")

            # Handle cases for adding and updating tasks on Todoist
            if not is_added:
                if c_a['submission']['workflow_state'] == "unsubmitted":
                    self.todoist_helper.create_task(c_a, t_proj_id)
                    summary['added'].append(c_a)
                else:
                    logging.info(f"     INFO: Already submitted, skipping...")
                    summary['is-submitted'].append(c_a)
            elif not is_synced:
                self.update_task(c_a, item)
                summary['updated'].append(c_a)
            else:
                logging.info(f"     OK: Task is already up to date!")
                summary['up-to-date'].append(c_a)
            logging.info(f"     Course: {c_cn}")
            logging.info(f"     Due Date: {c_d}")
            logging.info(f"     Priority: {TodoistHelper.get_priority_name(priority)}")

        # Commit changes to Todoist
        self.todoist_helper.api.commit(raise_on_error=True)

        # Print out short summary
        logging.info("")
        logging.info(f"# Short Summary:")
        logging.info(f"  * Added: {len(summary['added'])}")
        logging.info(f"  * Updated: {len(summary['updated'])}")
        logging.info(f"  * Already Submitted: {len(summary['is-submitted'])}")
        logging.info(f"  * Up to Date: {len(summary['up-to-date'])}")

        if len(summary['added']) > 0 or len(summary['updated']) > 0:
            logging.info("New tasks added or updated. Sending notification.")
            n_title = f"Canvas to Todoist (Total: {len(assignments)})"
            n_msg = f"Added {len(summary['added'])} & Updated {len(summary['updated'])}.\n" \
                    f"Completed: {len(summary['is-submitted'])} & Up-to-Date {len(summary['up-to-date'])}."
            NotificationHelper.send_notification(n_title, n_msg)
        else:
            logging.info("No new tasks added or updated. Skipping notification.")

        # Print detailed summary?
        logging.info("")
        if not self.skip_confirmation_prompts:
            answer = input("Q: Print Detailed Summary? (Y/n): ")
        else:
            answer = "y"

        if answer.lower() == 'y':
            logging.info("")
            logging.info(f"# Detailed Summary:")
            for cat in reversed(summary.keys()):
                a_list = summary[cat]
                logging.info(f"  * {cat.upper()}: {len(a_list)}")
                for i, c_a in enumerate(a_list):
                    c_n = c_a['name']
                    c_cn = self.selected_course_ids[str(c_a['course_id'])]['name']
                    a_p = c_a['priority']
                    a_d = c_a['due_at']
                    d = None
                    if a_d:
                        d = datetime.strptime(a_d, '%Y-%m-%dT%H:%M:%SZ')
                    # Convert to format: May 22, 2022 at 12:00 PM
                    d_nat = "Unknown" if d is None else d.strftime(
                        '%b %d, %Y at %I:%M %p')
                    logging.info(f"    {i + 1}. \"{c_n}\"")
                    logging.info(f"         Course: {c_cn}")
                    logging.info(f"         Due Date: {d_nat}")
                    logging.info(f"         Priority: {TodoistHelper.get_priority_name(a_p)}")

    @staticmethod
    def update_task(c_a, t_task):
        """
        Updates an existing task from a Canvas assignment object to Todoist
        """
        updates_list = []
        # Check if due date has changed
        t_d = t_task['due']['date'] if t_task['due'] else None
        c_d = c_a['due_at']
        if t_d != c_d:
            updates_list.append('due date')
        # Check if priority has changed
        t_p = t_task['priority']
        c_p = c_a['priority']
        # Print changes
        if t_p != c_p:
            updates_list.append('priority')
        logging.info(f"     UPDATE: Updating Task: " + ", ".join(updates_list))
        # Update Todoist task
        t_task.update(due={
            'date': c_d,
        },
            priority=c_p)


def main():
    logging.info("###################################################")
    logging.info("#     Canvas-Assignments-Transfer-For-Todoist     #")
    logging.info("###################################################")
    logging.info(f"Logs saved to: {log_path}")
    logging.info("")

    # Parse arguments and extract boolean flag -y which defaults to false
    parser = argparse.ArgumentParser(
        description='Transfer Canvas assignments to Todoist')
    parser.add_argument('-y', '--yes', action='store_true',
                        help='Skip confirmation prompts')
    # Get value of -y flag
    args = parser.parse_args()
    skip_confirmation_prompts = args.yes

    if skip_confirmation_prompts:
        logging.info("Skipping confirmation prompts")

    ct = CanvasToTodoist(skip_confirmation_prompts)
    ct.run()

    cd = CanvasFileDownloader(skip_confirmation_prompts)
    cd.run()


if __name__ == "__main__":
    # Main Execution
    main()
